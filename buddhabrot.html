<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Buddhabrot cuadrado centrado</title>
    <link rel="icon" href="s-l1200.ico" type="image/x-icon">
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background: #000;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        body {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }

        #buddhabrot {
            display: block;
            background: #000;
            /* Sin max-width ni height: 100vh ni object-fit */
            box-shadow: 0 0 64px #000 inset;
        }

        #loading {
            position: fixed;
            z-index: 10;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            color: #fff;
            font-family: 'Noto Sans', Arial, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3vw;
            font-variant-numeric: tabular-nums;
            text-shadow: 0 0 32px #fff, 0 0 8px #ffc300;
            letter-spacing: 0.09em;
            transition: opacity 0.4s;
            pointer-events: none;
            user-select: none;
            opacity: 1;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
            transition: opacity 1.2s;
        }
    </style>
</head>

<body>
    <div id="loading"></div>
    <canvas id="buddhabrot"></canvas>
    <script>
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 700;
        }
        function getCanvasSize() {
            const pixelRatio = window.devicePixelRatio || 1;
            // Cogemos el mayor de ancho o alto de la ventana (en CSS pixels)
            const rawSizeCss = Math.max(window.innerWidth, window.innerHeight);
            // Pasamos a device pixels
            let size = Math.floor(rawSizeCss * pixelRatio);
            // (Opcional) Limita para no llegar a >4096px en desktop o >2048 en móvil
            const maxDim = isMobile() ? 2048 : 4096;
            if (size > maxDim) size = maxDim;
            return { size, rawSizeCss };
        }
        function colorGrad(val) {
            if (val < 0.20) {
                let t = val / 0.20;
                return [0 + t * 60, 0 + t * 100, 0 + t * 255];
            } else if (val < 0.45) {
                let t = (val - 0.20) / 0.25;
                return [60 + t * 195, 100 + t * 155, 255];
            } else if (val < 0.80) {
                let t = (val - 0.45) / 0.35;
                return [255, 255, 255 - t * 192];
            } else {
                let t = (val - 0.80) / 0.20;
                return [255, 255 - t * 255, 63 - t * 63];
            }
        }
        function getComplexPlane(size) {
            let reMin = -2, reMax = 1;
            // Calcula el centro y el span para centrar el Buda y evitar el corte abajo
            let imCenter = 0.05;  // centro vertical típico del buddhabrot
            let imSpan = reMax - reMin;
            let imMin = imCenter - imSpan / 2;
            let imMax = imCenter + imSpan / 2;
            return { reMin, reMax, imMin, imMax };
        }
        function showLoading(percent) {
            const loader = document.getElementById("loading");
            loader.textContent = percent === undefined ? "" : `${percent}%`;
            loader.classList.remove("hidden");
            loader.style.display = 'flex';
        }
        function hideLoading() {
            const loader = document.getElementById("loading");
            loader.classList.add("hidden");
            setTimeout(() => loader.style.display = 'none', 1200);
        }
        let rendering = false;
        function startBuddhabrot() {
            rendering = true;

            const canvas = document.getElementById('buddhabrot');
            const { size, rawSizeCss } = getCanvasSize();
            canvas.width = canvas.height = size;
            // Ese size/rawSizeCss hará que el canvas CSS tenga el lado mayor de la ventana
            canvas.style.width = `${rawSizeCss}px`;
            canvas.style.height = `${rawSizeCss}px`;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, size, size);
            const plane = getComplexPlane(size);
            const maxIter = isMobile() ? 800 : 1600;
            const muestras = isMobile()
                ? Math.max(280000, Math.floor(size * size * 0.22))
                : Math.max(1800000, Math.floor(size * size * 0.95));
            const bailout = 4;
            const minIterEsc = 10;
            let acc = new Uint32Array(size * size);
            let procesados = 0;
            let lotes = 100;
            let batch = Math.floor(muestras / lotes);
            function procesarLote() {
                for (let i = 0; i < batch && procesados < muestras; i++, procesados++) {
                    let c_re = Math.random() * (plane.reMax - plane.reMin) + plane.reMin;
                    let c_im = Math.random() * (plane.imMax - plane.imMin) + plane.imMin;
                    let zs = [];
                    let z_re = 0, z_im = 0;
                    let escaped = false, iter = 0;
                    while (iter < maxIter) {
                        zs.push([z_re, z_im]);
                        let z_re_new = z_re * z_re - z_im * z_im + c_re;
                        let z_im_new = 2 * z_re * z_im + c_im;
                        z_re = z_re_new;
                        z_im = z_im_new;
                        if (z_re * z_re + z_im * z_im > bailout) {
                            escaped = true;
                            break;
                        }
                        iter++;
                    }
                    if (escaped && iter > minIterEsc) {
                        for (let [zr, zi] of zs) {
                            // Mapeo cuadrado, “de pie”
                            let y = Math.floor((zr - plane.reMin) / (plane.reMax - plane.reMin) * size);
                            let x = Math.floor((plane.imMax - zi) / (plane.imMax - plane.imMin) * size);
                            if (x >= 0 && x < size && y >= 0 && y < size)
                                acc[y * size + x]++;
                        }
                    }
                }
                let percent = Math.round(procesados / muestras * 100);
                showLoading(percent);
                if (procesados < muestras && rendering) {
                    setTimeout(procesarLote, 1);
                } else if (rendering) {
                    renderizar(acc, ctx, size);
                }
            }
            procesarLote();
        }
        function renderizar(acc, ctx, size) {
            showLoading(100);
            setTimeout(() => {
                let max = 1;
                for (let i = 0; i < acc.length; i++) max = Math.max(max, acc[i]);
                let img = ctx.createImageData(size, size);
                for (let y = 0; y < size; y++) for (let x = 0; x < size; x++) {
                    let val = acc[y * size + x];
                    let norm = val ? Math.log(val) / Math.log(max) : 0;
                    let [r, g, b] = colorGrad(norm);
                    let i = (y * size + x) * 4;
                    img.data[i] = r;
                    img.data[i + 1] = g;
                    img.data[i + 2] = b;
                    img.data[i + 3] = Math.max(110, 255 * Math.pow(norm, 0.85));
                }
                ctx.putImageData(img, 0, 0);
                rendering = false;
                hideLoading();
            }, 40);
        }
        // --- THROTTLE RESIZE ---
        let resizeTimeout;
        function onResizeThrottled() {
            // Solo ajusta el canvas visible al tamaño nuevo (sin recalcular)
            const { size } = getCanvasSize();
            const canvas = document.getElementById('buddhabrot');
            canvas.style.width = canvas.style.height = `${size / (window.devicePixelRatio || 1)}px`;
            if (resizeTimeout) clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                renderPage();
            }, 1200);
        }
        function renderPage() {
            showLoading(0);
            startBuddhabrot();
        }
        window.addEventListener('DOMContentLoaded', renderPage);
        window.addEventListener('resize', onResizeThrottled);
    </script>
</body>

</html>