<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>ü•¶</title>
    <link rel="icon" href="s-l1200.ico" type="image/x-icon">
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background: #000;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        body {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #buddhabrot {
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            display: block;
            object-fit: contain;
            background: #000;
            z-index: 1;
            position: relative;
            transition: width 0.4s, height 0.4s;
        }

        #loading {
            position: fixed;
            z-index: 10;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            color: #fff;
            font-family: 'Noto Sans', Arial, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3vw;
            font-variant-numeric: tabular-nums;
            text-shadow: 0 0 32px #fff, 0 0 8px #ffc300;
            letter-spacing: 0.09em;
            transition: opacity 0.4s;
            pointer-events: none;
            user-select: none;
            opacity: 1;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
            transition: opacity 1.2s;
        }
    </style>
</head>

<body>
    <div id="loading"></div>
    <canvas id="buddhabrot"></canvas>
    <script>
        // --- DISPOSITIVO: true si m√≥vil/tablet ---
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 700;
        }

        // --- CANVAS SIZE ---
        function getCanvasSize() {
            const pixelRatio = window.devicePixelRatio || 1.5;
            const maxDim = isMobile() ? 2048 : 4096;
            let w = Math.floor(window.innerWidth * pixelRatio);
            let h = Math.floor(window.innerHeight * pixelRatio);
            if (w > maxDim) { h = Math.floor(h * maxDim / w); w = maxDim; }
            if (h > maxDim) { w = Math.floor(w * maxDim / h); h = maxDim; }
            return { w, h };
        }

        // --- GRADIENTE ---
        function colorGrad(val) {
            if (val < 0.20) {
                let t = val / 0.20;
                return [
                    0 + t * 60,
                    0 + t * 100,
                    0 + t * 255
                ];
            } else if (val < 0.45) {
                let t = (val - 0.20) / 0.25;
                return [
                    60 + t * 195,
                    100 + t * 155,
                    255
                ];
            } else if (val < 0.80) {
                let t = (val - 0.45) / 0.35;
                return [
                    255,
                    255,
                    255 - t * 192
                ];
            } else {
                let t = (val - 0.80) / 0.20;
                return [
                    255,
                    255 - t * 255,
                    63 - t * 63
                ];
            }
        }

        // --- FRACTAL PLANE ---
        function getComplexPlane(w, h) {
            const aspectCanvas = w / h;
            const aspectFractal = 3 / 2.3;
            let reMin = -2, reMax = 1, imMin = -1.1, imMax = 1.2;
            if (aspectCanvas > aspectFractal) {
                let ancho = aspectCanvas * (imMax - imMin);
                let centro = (reMax + reMin) / 2;
                reMin = centro - ancho / 2;
                reMax = centro + ancho / 2;
            } else {
                let alto = (reMax - reMin) / aspectCanvas;
                let centro = (imMax + imMin) / 2;
                imMin = centro - alto / 2;
                imMax = centro + alto / 2;
            }
            return { reMin, reMax, imMin, imMax };
        }

        // --- LOADER PANTALLA ---
        function showLoading(percent) {
            const loader = document.getElementById("loading");
            loader.textContent = percent === undefined ? "" : `${percent}%`;
            loader.classList.remove("hidden");
            loader.style.display = 'flex';
        }
        function hideLoading() {
            const loader = document.getElementById("loading");
            loader.classList.add("hidden");
            setTimeout(() => loader.style.display = 'none', 1200);
        }

        // --- RENDER BUDDHABROT ---
        let rendering = false;
        function startBuddhabrot() {
            rendering = true;
            const { w, h } = getCanvasSize();
            const canvas = document.getElementById('buddhabrot');
            canvas.width = w;
            canvas.height = h;
            canvas.style.width = "100vw";
            canvas.style.height = "100vh";
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, w, h);

            const plane = getComplexPlane(w, h);
            const maxIter = isMobile() ? 1000 : 1600;
            const muestras = isMobile()
                ? Math.max(650000, Math.floor(w * h * 0.35))
                : Math.max(2600000, Math.floor(w * h * 1.25));
            const bailout = 4;
            const minIterEsc = 12;

            let acc = new Uint32Array(w * h);
            let procesados = 0;
            let lotes = 100;
            let batch = Math.floor(muestras / lotes);

            function procesarLote() {
                for (let i = 0; i < batch && procesados < muestras; i++, procesados++) {
                    let c_re = Math.random() * (plane.reMax - plane.reMin) + plane.reMin;
                    let c_im = Math.random() * (plane.imMax - plane.imMin) + plane.imMin;
                    let zs = [];
                    let z_re = 0, z_im = 0;
                    let escaped = false, iter = 0;
                    while (iter < maxIter) {
                        zs.push([z_re, z_im]);
                        let z_re_new = z_re * z_re - z_im * z_im + c_re;
                        let z_im_new = 2 * z_re * z_im + c_im;
                        z_re = z_re_new;
                        z_im = z_im_new;
                        if (z_re * z_re + z_im * z_im > bailout) {
                            escaped = true;
                            break;
                        }
                        iter++;
                    }
                    if (escaped && iter > minIterEsc) {
                        for (let [zr, zi] of zs) {
                            // Este mapea para que salga "de pie", cabeza arriba
                            let y = Math.floor((zr - plane.reMin) / (plane.reMax - plane.reMin) * h);
                            // Y este invierte el eje X para que el ‚Äúfrente‚Äù mire hacia ti:
                            let x = Math.floor((plane.imMax - zi) / (plane.imMax - plane.imMin) * w);
                            if (x >= 0 && x < w && y >= 0 && y < h)
                                acc[y * w + x]++;
                        }
                    }
                }
                let percent = Math.round(procesados / muestras * 100);
                showLoading(percent);
                if (procesados < muestras && rendering) {
                    setTimeout(procesarLote, 1);
                } else if (rendering) {
                    renderizar(acc, ctx, w, h);
                }
            }
            procesarLote();
        }

        function renderizar(acc, ctx, w, h) {
            showLoading(100);
            setTimeout(() => {
                let max = 1;
                for (let i = 0; i < acc.length; i++) max = Math.max(max, acc[i]);
                let img = ctx.createImageData(w, h);
                for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
                    let val = acc[y * w + x];
                    let norm = val ? Math.log(val) / Math.log(max) : 0;
                    let [r, g, b] = colorGrad(norm);
                    let i = (y * w + x) * 4;
                    img.data[i] = r;
                    img.data[i + 1] = g;
                    img.data[i + 2] = b;
                    img.data[i + 3] = Math.max(110, 255 * Math.pow(norm, 0.85));
                }
                ctx.putImageData(img, 0, 0);
                rendering = false;
                hideLoading();
            }, 40);
        }

        // --- THROTTLE RESIZE ---
        let resizeTimeout;
        function onResizeThrottled() {
            // Solo ajusta el canvas visible al tama√±o nuevo (sin recalcular)
            const { w, h } = getCanvasSize();
            const canvas = document.getElementById('buddhabrot');
            canvas.style.width = "100vw";
            canvas.style.height = "100vh";
            // Espera a que el usuario termine de hacer resize
            if (resizeTimeout) clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Ahora s√≠, recalcula el Buddhabrot
                renderPage();
            }, 1200);
        }

        function renderPage() {
            showLoading(0);
            startBuddhabrot();
        }

        window.addEventListener('DOMContentLoaded', renderPage);
        window.addEventListener('resize', onResizeThrottled);

    </script>
</body>

</html>